#Sử Dụng 1 Engine:
1. cài đặt
2. 
app.set('views', path.join(__dirname, 'views')); // set folder views
nó sẽ tự động tìm đến đúng folder views dù ta chạy file server.js ở bất kỳ đâu
(const path = require('path');)
3. rồi mới gọi res


#Sử dụng file .env để lưu trữ, khai báo các tham số môi trường
- Phải cài đặt thư viện dotenv mới sd được
- khai bao: require('dotenv').config(); // goi dotenv
- goi : process.env.PORT

#Sử dụng nodemon để tự động cập nhật trang
- thay node trong "start" bang nodemon de su dung


#Sử dụng static file:
-Khai báo: app.use(express.static(path.join(__dirname, 'public'))); // set folder public
sẽ khai báo với express rằng các file static như images,css,.. sẽ ở trong thư mục 'public,


#Cách tách conflig viewEngine:
-Khai báo tất cả các requuire cần thiết:
    const path = require('path');
    const express = require('express');
-Move engine cònlig vào file:
    const confligViewEngine = (app) => {
        app.set('views', path.join('./src', 'views')); // set folder views
        app.set('view engine', 'ejs'); // set view engine

        //conflig static file
        app.use(express.static(path.join('./src', 'public'))); // set folder public
    }

    phải sử dụng ./src thay __dirname vì __dirname sẽ chiếu đến folder hiện tại(conflig) trong khi cái folder views và public lại ở src
- module.exports = confligViewEngine; // để có thể sử dụng  confligViewEngine trong file server
- confligViewEngine(app); gọi confligViewEngine trong file server

#Cách tách routes:
- Khai báo cần thiết:
    const express = require('express')
    const router = express.Router();
- Copy các hàm từ server qua file khác, lưu ý thay thế app -> router :
    router.get('/', (req, res) => {
        // res.send('Hello World');
        res.render('sample.ejs');
    });
    router.get('/abc', (req, res) => {
        res.send('Check abc/nodemon');
    });
    router.get('/html', (req, res) => {
        res.send('<h1>Check html</h1>');
    });
- module.exports = router; // để dùng router trong file server
- Khai báo trong file server: const webRoutes = require('./routes/web')
 Vì dùng module.exports nên sẽ tự động map webRoutes vào router nên k cần đặt tên giống nhau
- Sử dụng trong server: 
    app.use('/', webRoutes)
    lưu ý webRoutes sẽ đc thực thi sau đường link '/' 
    VD: nếu link là '/abc' thì phải truy cập đến http://localhost:3000/abc mới hiển thị các phần trong webRoutes


# Cách tách code từ route sang các hàm con từ file thực thi khác:
 - Copy chi tiết thực thi các hàm từ file tổng route vào ở trong các file thực thi:
    const getHomePage = (req, res) => {
        return res.send('Hello World from controller');
    }
 - module.exports = {
        getHomePage,
        getABC
    }
    // export các hàm
 - Gọi trong route:
    router.get('/home', getHomePage);
    router.get('/abc', getABC);

# Docker để chạy Database: giúp dự án chạy đc trên nhiều loại máy, version
# DBeaver để kết nối với database
# Cách kết nối Database:
// Cách này sẽ ko áp dụng trong thực tế
 - Khai báo: const mysql = require('mysql2');
 - Connect đến database:
    const connection = mysql.createConnection({
        host: 'localhost',
        port: 3307, //default 3306
        user: 'root', // default empty
        password: '123456',
        database: 'hoidanit'
    });
    // khai báo như này sẽ khó bỏa trì , fix

    Nên dùng:
    const connection = mysql.createConnection({
        host: process.env.DB_HOST, // default localhost
        port: process.env.DB_PORT, //default 3306
        user: process.env.DB_USER, // default empty
        password: process.env.DB_PASSWORD,
        database: process.env.DB_NAME
    });
 - Gọi Query:
    connection.query(
        'Select * from Users u',
        function (err, results, fields) {
            console.log('>>Checkresults :', results); // results contains rows returned by server
            console.log('>>Checkfields :', fields); // fields contains extra meta data about results, if available
        }
    )
    // Result là những dữ liệu cần chú ý

//Thực hiện kết nối database thực tế với pools: giới hạn số lượng truy cập để tránh quá tải 

    const connection = mysql.createPool({
        host: process.env.DB_HOST,  // default localhost
        port: process.env.DB_PORT,  //default 3306
        user: process.env.DB_USER,  // default empty
        password: process.env.DB_PASSWORD,
        database: process.env.DB_NAME,
        waitForConnections: true,   // chờ khi hết kết nối thay vì báo lỗi ngay
        connectionLimit: 10,        // tối đa 10 kết nối cùng lúc trong pool
        queueLimit: 0               // số lượng request kết nối được xếp hàng (0 = không giới hạn)
    });

// Tuy nhiên nên thực thi theo async await thì sẽ tường minh hơn:
        let { email, name, city } = req.body;
        let [results, fields] = await connection.query(
            `INSERT INTO Users (email, name, city) VALUES (?, ?, ?)`, [email, name, city]
        );
        console.log('>>check results: ', results)
        res.send('Create user success')

    Chú ý database phải import promise: const mysql = require('mysql2/promise');

    
# Lấy input từ form bằng req.body:
    - Khai báo để sử dụng req.body
        //conflig req.body
        app.use(express.urlencoded({ extended: true })); // for form data
        app.use(express.json()); // for json

    - Hiện thực form kèm action:
        <form action="/create" method="POST">
            <fieldset>
                <legend>Add new user</legend>
                    <div class="input-group">
                        <label>Email : </label>
                        <input type="text" name="email">
                    </di
                    <div class="input-group">
                        <label>Name : </label>
                        <input type="text" name="name">
                    </div>
                    <div class="input-group">
                        <label>City : </label>
                    <input type="text" name="city">
                    </div>
                    <div>
                        <button class="save">Save</button>
                    </div>
            </fieldset>
        </form>

    - form action="/create" method="POST" : sẽ chuyển qua route 'create' với lện post được nhận
    - Thêm các name="email", name="name", name="city" để nhận diện các dữ liệu lấy từ input
    - Dùng req.body để lấy dữ liệu:
        const postCreateUser = (req, res) => {
            console.log('req.body :', req.body);
            // xu ly them user
            return res.send('Post request to create new user from controller');
        }

# Sự khác biệt giữa async await và call back function: // Nên dùng async await hơn
 - Async await sẽ chạy tuần tự code từ trên xuống dưới, tránh được trường hợp dữ liệu chưa được load mà đã phải return
 - Call back function sẽ chạy code ngay tại thời điểm goi
 VD: const getHomePage = async (req, res) => {
        let results = await getAllUsers();
        console.log('>>Checkresults :', results); // results contains rows returned by server
        return res.render('home.ejs', { listUser: results });
    }
    Với Async await sẽ phải đợi results lấy kết quả từ getAllUsers đã rồi mới được return
    Với Call back func sẽ return luôn ngay lúc chạy đến mặc kệ results đã lấy được dữ liệu từ getAllUsers hay chưa, nên rất dễ dữ liệu sẽ thiếu hoặc rỗng.

# Lấy dữu liệu từ database trong ejs:
    <%=JSON.stringify(listUser) %>

# Lấy động tham số:
 - khai route động: router.get('/update/:id', getUpdateUser); // id chỉ là tên biến muốn đặt như nào cx đc
 - Check : 
    const getUpdateUser = (req, res) => {
        console.log('>>>Check req.params:', req.params);
        return res.render('edit.ejs')
    }
 - gán route động cho button: <a href="/update/<%= user.id %>"><button>Edit</button></a>



# ----------------------------------------------
# ------ Cách lấy và update dữ liệu ------------
# ----------------------------------------------
- nhảy đến route mới khi nhấn edit
    <a href="/update/<%= user.id %>"><button>Edit</button></a>
- Gọi hàm lấy dữ liệu:
    router.get('/update/:id', getUpdateUser);
- Render edit.ejs và truyền dữ liệu của obj đang gọi tới:
    const getUpdateUser = async (req, res) => {
        let userId = req.params.id;
        let [results, fields] = await connection.query('SELECT * FROM Users WHERE id = ?', [userId]);
        let user = results && results.length > 0 ? results[0] : {};
        return res.render('edit.ejs', { userEdit: user });
    }
- Cập nhật dữ liệu và post (trong edit.ejs)
- gọi : router.post('/update/:id', postUpdateUser);
- const postUpdateUser = async (req, res) => {
    let { email, name, city, userId } = req.body;               // lấy dữ liệu hiện có
    await updateUserById(email, name, city, userId);            // cập nhật dữ liệu
    res.redirect('/');                                          //quay về trang home sau khi update xong
}